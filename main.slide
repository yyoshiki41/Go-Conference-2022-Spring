Go API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å®Ÿè£…
Go Conference 2022 Spring
23 Apr 2022
Tags: golang, api, http

Yoshiki Nakagawa
@yyoshiki41

https://github.com/yyoshiki41

* AboutMe

[[https://github.com/yyoshiki41][@yyoshiki41]]

Yoshiki Nakagawa

- æ ªå¼ä¼šç¤¾LayerX

Gopher

- Go Conference ã¯ 2016 å¹´ä»¥æ¥
- é‹å–¶ãƒãƒ¼ãƒ ã¨ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®æ–¹ã€…ã«ã¯, ç¶™ç¶šé–‹å‚¬ã¸ã®å°½åŠ›ã«æ„Ÿè¬ã¨å°Šæ•¬ ğŸ™

* Go API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å®Ÿè£…

1. èªè¨¼
2. APIã‚³ãƒ¼ãƒ«ã®å®Ÿè£…
3. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
4. ãƒ†ã‚¹ãƒˆ

* èªè¨¼

ä¸»ãªã‚‚ã®ã ã¨ä¸‹è¨˜

1. ç™ºè¡Œã•ã‚ŒãŸ API Key ã‚’ä½¿ç”¨
2. OAuth èªè¨¼ã§, ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã—ã¦ä½¿ç”¨


* 1. API Key

	// Config is a setting for 3rd Party API.
	type Config struct {
		Endpoint string
		APIKey   string
	}

- Endpoint
`https://api.example.com`

- APIKey
`********abcd`

* Client ã®åˆæœŸåŒ–

	// Client represents an API client for 3rd Party API.
	type Client struct {
		config     *Config
	}

	// NewClient returns a new API client.
	func NewClient(config *Config) *Client {
		return &Client{
			config: config,
		}
	}

ã‚¢ãƒ—ãƒªã‹ã‚‰ã®å‘¼ã³å‡ºã—

	conf := NewConfig(endpoint, apiKey)
	client := NewClient(conf)
	
	resp, err := client.GetMe(ctx, tokenSource)

* 2. OAuth2

`golang.org/x/oauth2` ã‚’ä½¿ã†å ´åˆ

	type Config struct {
		Endpoint string
		OAuth2   *oauth2.Config
	}

- Endpoint
`https://api.example.com`

- OAuth2
`oauth2.Config`

`ClientID`, `ClientSecret`, `RedirectURL` ãªã©ãŒåˆæœŸåŒ–ã«å¿…è¦.

* Config ã®åˆæœŸåŒ–

	func NewConfig(apiEndpoint, clientID, clientSecret, redirectURL string) *Config {
		return &Config{
			Endpoint: apiEndpoint,
			OAuth2: &oauth2.Config{
				ClientID:     clientID,
				ClientSecret: clientSecret,
				RedirectURL:  redirectURL,
				Endpoint: oauth2.Endpoint{
					AuthURL:   Oauth2AuthURL,
					TokenURL:  Oauth2TokenURL,
					AuthStyle: oauth2.AuthStyleInParams,
				},
			},
		}
	}

* ã‚¢ãƒ—ãƒªã‹ã‚‰ã®å‘¼ã³å‡ºã—

	conf := NewConfig(clientID, clientSecret, redirectURL)
	client := NewClient(conf)

	token := &oauth2.Token{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		Expiry:       expiredAt,
	}
	tokenSource := conf.OAuth2.TokenSource(ctx, token)
	resp, err := client.GetMe(ctx, tokenSource)

å‡¦ç†ã®æµã‚Œï¼ˆæ—¢ã«ä¸€åº¦OAuth èªè¨¼ãŒå®Œäº†ã—ã¦ã„ã‚‹å‰æï¼‰

1. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«æƒ…å ±ãªã©ã‚’ã‚»ãƒƒãƒˆã—, ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆæœŸåŒ–
2. Persistent Storage ãªã©ã§ä¿å­˜ã—ã¦ã„ãŸ token (ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³, ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³) ã‚’ã‚»ãƒƒãƒˆ
3. API ã‚³ãƒ¼ãƒ«
ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”¨ã„ã¦ã®ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³å†ç™ºè¡Œã‚‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã§è¡Œã†

* TokenSource

`oauth2.Token` ã¨ `err` ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹.
`TokenSource.Token()` è‡ªä½“ã¯, `http.Client` ã® Transport å±¤ã§å‘¼ã°ã‚Œã‚‹.

`RoundTripper` ãŒAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆå‰ã«ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ã‹ã®æ¤œè¨¼ã‚’è¡Œã†.
æœ‰åŠ¹æœŸé™åˆ‡ã‚Œã®ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®å ´åˆã«ã¯ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”¨ã„ã¦, `oauth2.Token` ã®å†å–å¾—ã‚’è¡Œã†å®Ÿè£…ã«ãªã£ã¦ã„ã‚‹.

	type TokenSource interface {
		// Token returns a token or an error.
		// Token must be safe for concurrent use by multiple goroutines.
		// The returned Token must not be modified.
		Token() (*Token, error)
	}

`Token()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `Transport.RoundTrip()` ã§å‘¼ã°ã‚Œã‚‹ãŸã‚, concurrency-safe ã«ãªã‚‹ã‚ˆã†æ³¨æ„ãŒå¿…è¦.

c.f. [[https://pkg.go.dev/net/http#RoundTripper][net/http#RoundTripper]]

	A RoundTripper must be safe for concurrent use by multiple goroutines.

* RoundTripper

Transport å±¤ã§ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®åˆ¶å¾¡ãŒè¡Œãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹.

c.f. [[https://pkg.go.dev/net/http#RoundTripper][net/http#RoundTripper]]

	RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.

- ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒªãƒˆãƒ©ã‚¤ã®åˆ¶å¾¡

- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«

- è©³ç´°ãªãƒ­ã‚°ã‚„ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å–ã£ã¦è»¢é€ã™ã‚‹.

- ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã§å¤–éƒ¨ã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡Œã‚ãšã«, ãƒ†ã‚¹ãƒˆæœŸå¾…å€¤ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¨ã—ã¦è¿”ã—ãŸã„å ´åˆ

* golang.org/x/oauth2 ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® RoundTripper

	// Transport is an http.RoundTripper that makes OAuth 2.0 HTTP requests,
	// wrapping a base RoundTripper and adding an Authorization header
	// with a token from the supplied Sources.
	//
	// Transport is a low-level mechanism. Most code will use the
	// higher-level Config.Client method instead.
	type Transport struct {
		// Source supplies the token to add to outgoing requests'
		// Authorization headers.
		Source TokenSource
	
		// Base is the base RoundTripper used to make HTTP requests.
		// If nil, http.DefaultTransport is used.
		Base http.RoundTripper
	}
	
	// RoundTrip authorizes and authenticates the request with an
	// access token from Transport's Source.
	func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error)

* TokenSource

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«ã“ã®å®Ÿè£…ãŒå…¥ã£ã¦ã„ã‚Œã°, ã‚¢ãƒ—ãƒªå´ã§ token ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãªã©ã‚’æ°—ã«ã—ãªãã¦ã‚ˆããªã‚Šã¾ã™ã€‚

golang.org/x/oauth2 ã®å®Ÿè£…ä»¥å¤–ã§å¯¾å¿œã™ã‚‹å ´åˆ, è‡ªåŠ›ã§ã®å®Ÿè£…ãŒå¿…è¦ã«ãªã£ã¦ãã¾ã™.

* OAuth2 ã®æ‹¡å¼µçš„ãªä»•æ§˜ãŒæ±‚ã‚ã‚‰ã‚ŒãŸä¾‹

1. Authorization Code Flow ã§, ç‹¬è‡ªã®HTTPãƒ˜ãƒƒãƒ€ãƒ¼ãŒå¿…è¦

	-H "X-CompanyID: 1234"

2. OAuth Token Endpoint ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒç‹¬è‡ªæƒ…å ±ã‚’æŒã£ã¦ã„ã‚‹

`golang.org/x/oauth2` ã® `Token` ([[https://www.rfc-editor.org/rfc/rfc6749.html][RFC6749]])

	type Token struct {
		AccessToken  string      `json:"access_token"`
		TokenType    string      `json:"token_type,omitempty"`
		RefreshToken string      `json:"refresh_token,omitempty"`
		Expiry       time.Time   `json:"expiry,omitempty"`
		raw          interface{}
	}

æ‹¡å¼µã•ã‚ŒãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹æƒ…å ±ã¯, `raw` ã¨ã„ã†ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ç”¨æ„ã•ã‚Œã¦ã„ã‚‹.

	func (t *Token) Extra(key string) interface{}
	func (t *Token) WithExtra(extra interface{}) *Token

* TokenSource ã‚’å®Ÿè£…ã—ã¦ã¿ã‚‹

* oauth2.ReuseTokenSource

token åˆæœŸå€¤ã¨ ç‹¬è‡ªã®å®Ÿè£…ã‚’ã—ãŸ `TokenSource` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æº€ãŸã™ `tokenRefresher` ã‚’ã‚»ãƒƒãƒˆã—ã¦åˆæœŸåŒ–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°.

ã“ã®é–¢æ•°ã« token (ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³) ã‚’æ¸¡ã™ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ã§ã‚ã‚‹é–“ã¯, Oauth ãƒ€ãƒ³ã‚¹ã‚’æœ€åˆã‹ã‚‰è¡Œã†å¿…è¦ãªã, Token Endpoint ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã—ã¦ãã‚Œã‚‹.

	func (c *Client) TokenSource(ctx context.Context, token *oauth2.Token) oauth2.TokenSource {
		return oauth2.ReuseTokenSource(
			token,
			&tokenRefresher{
				ctx:          ctx,
				conf:         c.config,
				refreshToken: token.RefreshToken,
			})
	}

	type tokenRefresher struct {
		ctx          context.Context
		conf         *Config
		refreshToken string
	}

* tokenRefresher.Token ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…

`retrieveToken()` ã§, OAuth Token Endpoint ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å†ç™ºè¡Œã™ã‚‹.

	func (tf *tokenRefresher) Token() (*oauth2.Token, error) {
		if tf.refreshToken == "" {
			return nil, ErrRefreshTokenIsNotSet
		}
		params := url.Values{
			"client_id":     {tf.conf.Oauth2.ClientID},
			"client_secret": {tf.conf.Oauth2.ClientSecret},
			"grant_type":    {"refresh_token"},
			"refresh_token": {tf.refreshToken},
		}
		// IMPLEMENT YOUR CUSTOM retrieveToken FUNCTION
		tk, err := retrieveToken(tf.ctx, tf.conf, params)
		if err != nil {
			return nil, err
		}
		if tf.refreshToken != tk.RefreshToken {
			tf.refreshToken = tk.RefreshToken
		}
		return tk, nil
	}

* tokenRefresher ã®å®Ÿè£…

	func retrieveToken(ctx context.Context, conf *Config, params url.Values) (*TokenResponse, error) {
		body := strings.NewReader(params.Encode())
		req, err := http.NewRequest(http.MethodPost, conf.Oauth2.Endpoint.TokenURL, body)
		if err != nil {
			return nil, err
		}
		// SET YOUR CUSTOM HTTP HEADERS
		req.Header.Set("X-CompanyID", conf.CompanyID)
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		req = req.WithContext(ctx)
		response, err := http.DefaultClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		var r io.Reader = response.Body
		// DECODE YOUR CUSTOM RESPONSE
		token := &TokenResponse{}
		if err = json.NewDecoder(r).Decode(token); err != nil {
			return nil, err
		}
		...
	}

* ã‚¢ãƒ—ãƒªå´ã‹ã‚‰ã®å‘¼ã³å‡ºã—

	conf := NewConfig(clientID, clientSecret, redirectURL)
	client := NewClient(conf)
	token := oauth2.Token{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		Expiry:       expiredAt,
	}

	tokenSource := client.TokenSource(ctx, token)
	resp, err := client.GetMe(ctx, tokenSource)
	...
	token, err = tokenSource.Token()

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ã§ãªã„å ´åˆã«ã¯, refresh_token ã‹ã‚‰æ–°ãŸãªã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—ã‚’è¡Œã„, API ã‚³ãƒ¼ãƒ«ã®å®Ÿè¡Œã‚’è¡Œã£ã¦ãã‚Œã‚‹.
APIã‚³ãƒ¼ãƒ«å¾Œã«æ›´æ–°ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¯, `tokenSource.Token()` ã§å–å¾—å¯èƒ½.

* API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ±ç”¨çš„ãªå®Ÿè£…

* API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ±ç”¨çš„ãªå®Ÿè£…

`Client` ã«ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã® `call` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…

	func (c *Client) GetMe(
		ctx context.Context, tokenSource oauth2.TokenSource,
	) (*User, error) {
		var resp User
	
		err := c.call(ctx, tokenSource, path.Join(pathUser), http.MethodPost, nil, nil, &resp)
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}

1. ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãƒ‘ã‚¹, HTTPãƒ¡ã‚½ãƒƒãƒ‰ã¨ Body ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚„ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆ, `call` ãƒ¡ã‚½ãƒƒãƒ‰ã¸æ¸¡ã™.
2. `tokenSource` ã‚’ `call` ãƒ¡ã‚½ãƒƒãƒ‰ã¸æ¸¡ã™.
ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹æœŸé™åˆ‡ã‚Œã®å ´åˆã«ã¯, Transport å±¤ã§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã®æ›´æ–°ãŒè¡Œã‚ã‚Œã‚‹. ã‚¢ãƒ—ãƒªå´ã§ã‚‚ APIã‚³ãƒ¼ãƒ«å¾Œã«æ›´æ–°ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜å¯èƒ½ã«ã™ã‚‹.
3. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒã‚¤ãƒ³ã‚¿å‹ã§æ¸¡ã™. (jsonãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦, å€¤ã‚’å…¥ã‚Œã‚‹)

* API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ±ç”¨çš„ãªå®Ÿè£…

	func (c *Client) call(
		ctx context.Context, tokenSource oauth2.TokenSource,
		path string, method string, queryParams url.Values, postBody interface{}, res interface{},
	) error {
		var (
			contentType string
			body        io.Reader
		)
		if method != http.MethodDelete {
			contentType = "application/json"
			jsonParams, err := json.Marshal(postBody)
			if err != nil {
				return err
			}
			body = bytes.NewBuffer(jsonParams)
		}
	
		req, err := c.newRequest(ctx, path, method, contentType, queryParams, body)
		if err != nil {
			return err
		}
		return c.do(ctx, tokenSource, req, res)
	}

* API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ±ç”¨çš„ãªå®Ÿè£…

	func (c *Client) newRequest(
		ctx context.Context, apiPath string, method string,
		contentType string, queryParams url.Values, body io.Reader,
	) (*http.Request, error) {
		u, err := url.Parse(c.config.Endpoint)
		if err != nil {
			return nil, err
		}
		u.Path = path.Join(u.Path, apiPath)
		u.RawQuery = queryParams.Encode()

		req, err := http.NewRequest(method, u.String(), body)
		if err != nil {
			return nil, err
		}
		req = req.WithContext(ctx)
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
		}
		return req, nil
	}

* API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ±ç”¨çš„ãªå®Ÿè£…

	func (c *Client) do(
		ctx context.Context, tokenSource oauth2.TokenSource,
		req *http.Request, res interface{},
	) error {
		httpClient := oauth2.NewClient(ctx, tokenSource)
		response, err := httpClient.Do(req)
		if err != nil {
			return err
		}
		defer response.Body.Close()

		var r io.Reader = response.Body
		if code := response.StatusCode; code >= http.StatusBadRequest {
			byt, _ := io.ReadAll(r)
			return errors.New(byt.String())
		}
		if res == nil {
			return nil
		}
		if err := json.NewDecoder(r).Decode(&res); err != nil && err != io.EOF {
			return err
		}
		return nil
	}

* ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

* ã‚¨ãƒ©ãƒ¼å‹

`client.GetMe` ã®ã‚ˆã†ãªãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™ `err` ã®å‹

HTTP ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚„ RawError, å†èªè¨¼ãŒå¿…è¦ã‹ãªã©ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒãŸã›ã‚‹.

	type Error struct {
		StatusCode              int
		RawError                string
		IsAuthorizationRequired bool
	}
	
	func (e *Error) Error() string {
		return e.RawError
	}

* ã‚¢ãƒ—ãƒªå´ã§ã®ãƒãƒ³ãƒ‰ãƒ«

	func IsAuthorizationRequired(err error) bool {
		if v, ok := err.(*api.Error); ok {
			return v.IsAuthorizationRequired
		}
		return false
	}

ã‚¢ãƒ—ãƒªå´ã§ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ç”¨æ„ã—ã¦, ç´°ã‹ãªãƒãƒ³ãƒ‰ãƒ«ãŒå¯èƒ½.
ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½“é¨“ã«é–¢ã‚ã‚‹éƒ¨åˆ†ã¨ã—ã¦, API ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ã‹, refresh_token ãŒ revoke ã•ã‚Œã¦ãŠã‚Šå†åº¦ OAuthèªè¨¼ãŒå¿…è¦ãªã‚¨ãƒ©ãƒ¼ã‹ã‚’åˆ‡ã‚Šåˆ†ã‘ã‚‹ãªã©ã‚‚å‡ºæ¥ã‚‹.

	me, err := client.GetMe(ctx, tokenSource)
	if err != nil {
		if IsAuthorizationRequired(err) {
			// handle...
		}
		return err
	}

* API ã‚¨ãƒ©ãƒ¼ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

API å´ã§æ±ºã¾ã£ãŸã‚¨ãƒ©ãƒ¼ã®å‹ãŒã‚ã‚‹å ´åˆ, RawError ã‚’ `APIError` ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã‚’ç”¨æ„.

	type APIError struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Reason  string `json:"reason"`
	}
	
	func (e *Error) MustParseAPIError() *APIError {
		if e == nil || e.RawError == "" {
			return nil
		}
		aErr := APIError{}
		if err := json.Unmarshal([]byte(e.RawError), &aErr); err != nil {
			return nil
		}
		return &aErr
	}

API ã‚µãƒ¼ãƒãƒ¼ãŒæ±ºã‚ã‚‰ã‚ŒãŸå‹ã§ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã•ãªã„ã‚±ãƒ¼ã‚¹ã‚’è€ƒæ…®ã—ã¦ã®ã‚‚ã®.
ä¾‹ãˆã°, API ã‚µãƒ¼ãƒãƒ¼å‰æ®µã®ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µãƒ¼ãŒ "service temporary unavailable" ã‚’APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¨ã—ã¦è¿”ã™å ´åˆã§ã¯, `APIError` ã¸ã®ãƒ‘ãƒ¼ã‚¹ã¯è¡Œãˆãªã„.

* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å®Ÿè£…ã™ã‚‹

	response, err := httpClient.Do(req)
	if err != nil {
		// handle...
	}

`http.Client.Do` ã‹ã‚‰è¿”ã£ã¦ãã‚‹ `err` ã®å‡¦ç†.

c.f. [[https://pkg.go.dev/net/http#Client.Do][net/http#Client.Do]]

	Any returned error will be of type *url.Error.
	The url.Error value's Timeout method will report true if the request timed out.

`url.Error` å‹ã§è¿”ã£ã¦ãã‚‹ `err` ã‚’ 2æ®µéšã®å‡¦ç†ã§ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹.

* Transportå±¤ã§ã®ã‚¨ãƒ©ãƒ¼

æœ€åˆã« `errors.As` ã§ `oauth2.RetrieveError` (Transport å±¤ã§èµ·ããŸOAuthã‚¨ãƒ©ãƒ¼) ã«ã‚¢ã‚µã‚¤ãƒ³å¯èƒ½ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹.
ï¼ˆ`Unwrap` ã¯ `errors.As` å†…ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ï¼‰

èªè¨¼ã‚¨ãƒ©ãƒ¼ã®å ´åˆ, IsAuthorizationRequired: true ã¨ã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã—ã¦ã‚ã’ã‚‹.

	errOauth2 := &oauth2.RetrieveError{}
	if errors.As(err, &errOauth2) {
		resp := &Error{
			RawError:                err.Error(),
			StatusCode:              http.StatusUnauthorized,
			IsAuthorizationRequired: true,
		}
		if errOauth2.Response != nil {
			resp.StatusCode = errOauth2.Response.StatusCode
		}
		return resp
	}

* Transportå±¤ã§ã®ã‚¨ãƒ©ãƒ¼

æ¬¡ã« OAuth ä»¥å¤–ã®ã‚¨ãƒ©ãƒ¼ã‚’åŒã˜ã, `Unwrap` ã—ãŸã‚ã¨ `RawError` ã¨ã—ã¦è¿”ã—ã¦ã„ã‚‹.
ï¼ˆä¾‹å¤–ç³»ã§ç™ºç”Ÿã™ã‚‹ã‚±ãƒ¼ã‚¹è‡ªä½“ã‚‚ã‚ã¾ã‚Šæ€ã„ã¤ã‹ãªã„.ï¼‰

	errURL := &url.Error{}
	if errors.As(err, &errURL) {
		resp := &Error{
			RawError: err.Error(),
		}
		return resp
	}
	return err

* Transportå±¤ã§ã®ã‚¨ãƒ©ãƒ¼

	response, err := httpClient.Do(req)
	if err != nil {
		errOauth2 := &oauth2.RetrieveError{}
		if errors.As(err, &errOauth2) {
			resp := &Error{
				RawError:                err.Error(),
				StatusCode:              http.StatusUnauthorized,
				IsAuthorizationRequired: true,
			}
			if errOauth2.Response != nil {
				resp.StatusCode = errOauth2.Response.StatusCode
			}
			return resp
		}
		errURL := &url.Error{}
		if errors.As(err, &errURL) {
			resp := &Error{
				RawError: err.Error(),
			}
			return resp
		}
		return err
	}

* API ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¨ãƒ©ãƒ¼

ç¶šã„ã¦ã¯, ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ã®ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†.
API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯, `RawError` ã«ä¿å­˜ã™ã‚‹. (`APIError` å‹ã§æ¬²ã—ã„å ´åˆã¯, å…ˆè¿°ã®ãƒ‘ãƒ¼ã‚¹ã™ã‚‹é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹.)

	response, err := httpClient.Do(req)
	if err != nil {
		// handle...
	}
	defer response.Body.Close()

	var r io.Reader = response.Body
	if code := response.StatusCode; code >= http.StatusBadRequest {
		byt, _ := io.ReadAll(r)
		res := &Error{
			StatusCode: code,
			RawError:   string(byt),
		}
		return res
	}

* ãƒ†ã‚¹ãƒˆç·¨

* ãƒ†ã‚¹ãƒˆç·¨

1. `httptest.Server` ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã«ç«‹ã¡ä¸Šã’ã¦ã®ãƒ†ã‚¹ãƒˆ

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ã®éš›ã«, APIEndpoint ã‚’å¤–éƒ¨ã‹ã‚‰å¤‰æ›´å¯èƒ½ã«ã™ã‚‹äº‹ã«ã‚ˆã£ã¦, ãƒ†ã‚¹ãƒˆæ™‚ã«ãƒ­ãƒ¼ã‚«ãƒ«ã® `httptest` ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨å·®ã—æ›¿ãˆãŒå¯èƒ½ã«ãªã‚‹.

2. ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã‚’è¡Œã‚ãªã„ `RoundTripper` ã‚’ `http.Client` ã«ç”¨ã„ã¦, æœŸå¾…å€¤ã‚’è¿”ã™

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ã®éš›ã«, `http.Client` ã‚’å¤–éƒ¨ã‹ã‚‰å¤‰æ›´å¯èƒ½ã«ã—ã¦, `httptest` ã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¡ä¸Šã’ãšã«ãƒ†ã‚¹ãƒˆå¯èƒ½ã«ã™ã‚‹.

ref. [[http://hassansin.github.io/Unit-Testing-http-client-in-Go][Unit Testing http client in Go]]

* httptest.Server ã§ã®ãƒ†ã‚¹ãƒˆ

æœŸå¾…å€¤ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å®Ÿè£…ã—ã¦, ãƒ­ãƒ¼ã‚«ãƒ«ä¸Šã«ã‚µãƒ¼ãƒ“ãƒ³ã‚°ã™ã‚‹.

	expected := func(w http.ResponseWriter, r *http.Request) {
		// ASSERT YOUR REQUEST VALUES
		// path == "/me"
		w.Write([]byte(`ok`))
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/me", expected)
	
	testserver := httptest.NewServer(mux)
	defer testserver.Close()

* httptest.Server ã§ã®ãƒ†ã‚¹ãƒˆ

ãƒ­ãƒ¼ã‚«ãƒ«ä¸Šã®ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ¸¡ã—ã¦ãƒ†ã‚¹ãƒˆ.

	conf := NewConfig(testServerURL, ...)
	client := NewClient(conf)
	res, err := client.GetMe()
	if err != nil {
		t.Error(err)
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		t.Error(err)
	}
	if body != []byte("ok") {
		t.Errorf("expected ok, but got: %s", string(body))
	}

* ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã‚’è¡Œã‚ãªã„ http.Client ã‚’ç”¨ã„ã¦ã®ãƒ†ã‚¹ãƒˆ

`DefaultTransport` ã¯ä½¿ã‚ãšã«, æœŸå¾…å€¤ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã™ã‚‹ `RoundTripper` ã‚’ãƒ†ã‚¹ãƒˆæ™‚ã«ã‚»ãƒƒãƒˆå‡ºæ¥ã‚‹ã‚ˆã†ã«ã™ã‚‹.

	type RoundTripFunc func(req *http.Request) *http.Response
	
	func (f RoundTripFunc) RoundTrip(req *http.Request) (*http.Response, error) {
		return f(req), nil
	}
	
	func NewTestHTTPClient(fn RoundTripFunc) *http.Client {
		return &http.Client{
			Transport: fn,
		}
	}

* ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã‚’è¡Œã‚ãªã„ http.Client ã‚’ç”¨ã„ã¦ã®ãƒ†ã‚¹ãƒˆ

æœŸå¾…å€¤ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã™ã‚‹ `RoundTripper` ã‚’å®Ÿè£…ã—ã¦, `http.Client` ã«ã‚»ãƒƒãƒˆã—ã¦ãƒ†ã‚¹ãƒˆ.

	expected := func(req *http.Request) *http.Response {
		// ASSERT YOUR REQUEST VALUES
		// path == "/me"
		return &http.Response{
			StatusCode: 200,
			Body:       ioutil.NopCloser(bytes.NewBufferString(`ok`)),
			Header:     make(http.Header),
		}
	}
	httpClient := NewTestHTTPClient(expected)

	conf := NewConfig(httpClient, ...)
	client := NewClient(conf)
	res, err := client.GetMe()
	...
